//! WebAssembly execution for dynamic code in RLM
//!
//! This module provides safe, sandboxed execution of WASM modules
//! generated by the LLM for complex analysis tasks.
//!
//! ## Modules
//!
//! - `compiler` - Rust to WASM compilation
//! - `cache` - Module caching for compiled WASM

pub mod cache;
pub mod compiler;
#[cfg(test)]
mod benchmark_tests;
#[cfg(test)]
mod demo_tests;
#[cfg(test)]
mod security_tests;

pub use cache::{CacheConfig, CacheStats, ModuleCache};
pub use compiler::{CompileError, CompilerConfig, RustCompiler};

use std::collections::HashMap;
use thiserror::Error;
use wasmtime::*;

/// Errors from WASM execution
#[derive(Error, Debug)]
pub enum WasmError {
    #[error("WASM compilation failed: {0}")]
    CompileError(String),

    #[error("WASM execution failed: {0}")]
    ExecutionError(String),

    #[error("WASM function not found: {0}")]
    FunctionNotFound(String),

    #[error("WASM out of fuel (instruction limit exceeded)")]
    OutOfFuel,

    #[error("WASM memory limit exceeded")]
    MemoryLimit,

    #[error("Invalid WAT syntax: {0}")]
    WatError(String),

    #[error("Type mismatch: expected {expected}, got {got}")]
    TypeMismatch { expected: String, got: String },
}

/// Configuration for WASM execution
#[derive(Debug, Clone)]
pub struct WasmConfig {
    /// Maximum instructions (fuel) before aborting
    pub fuel_limit: u64,
    /// Maximum memory in bytes
    pub memory_limit: usize,
    /// Timeout in milliseconds (not yet implemented)
    pub timeout_ms: u64,
}

impl Default for WasmConfig {
    fn default() -> Self {
        Self {
            fuel_limit: 1_000_000,          // 1M instructions
            memory_limit: 64 * 1024 * 1024, // 64MB
            timeout_ms: 5000,               // 5 seconds
        }
    }
}

/// WASM executor with sandboxing
pub struct WasmExecutor {
    engine: Engine,
    config: WasmConfig,
}

impl WasmExecutor {
    /// Create a new WASM executor
    pub fn new(config: WasmConfig) -> Result<Self, WasmError> {
        let mut engine_config = Config::new();
        engine_config.consume_fuel(true);

        let engine =
            Engine::new(&engine_config).map_err(|e| WasmError::CompileError(e.to_string()))?;

        Ok(Self { engine, config })
    }

    /// Compile WAT (WebAssembly Text) to a WASM module
    pub fn compile_wat(&self, wat: &str) -> Result<Vec<u8>, WasmError> {
        wat::parse_str(wat).map_err(|e| WasmError::WatError(e.to_string()))
    }

    /// Execute a WASM module with the given function and context
    ///
    /// The WASM module should export:
    /// - `alloc(size: i32) -> i32`: allocate memory for input
    /// - `free(ptr: i32, size: i32)`: free allocated memory
    /// - `<function>(ptr: i32, len: i32) -> i32`: the analysis function
    /// - `get_result_ptr() -> i32`: get pointer to result
    /// - `get_result_len() -> i32`: get length of result
    pub fn execute(
        &self,
        wasm_bytes: &[u8],
        function: &str,
        context: &str,
    ) -> Result<String, WasmError> {
        // Create a store with fuel limit
        let mut store = Store::new(&self.engine, ());
        store
            .set_fuel(self.config.fuel_limit)
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?;

        // Compile the module
        let module = Module::new(&self.engine, wasm_bytes)
            .map_err(|e| WasmError::CompileError(e.to_string()))?;

        // Create instance
        let instance = Instance::new(&mut store, &module, &[])
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?;

        // Get memory
        let memory = instance
            .get_memory(&mut store, "memory")
            .ok_or_else(|| WasmError::ExecutionError("No memory export".to_string()))?;

        // Get required functions
        let alloc = instance
            .get_typed_func::<i32, i32>(&mut store, "alloc")
            .map_err(|e| WasmError::FunctionNotFound(format!("alloc: {}", e)))?;

        let target_fn = instance
            .get_typed_func::<(i32, i32), i32>(&mut store, function)
            .map_err(|e| WasmError::FunctionNotFound(format!("{}: {}", function, e)))?;

        let get_result_ptr = instance
            .get_typed_func::<(), i32>(&mut store, "get_result_ptr")
            .map_err(|e| WasmError::FunctionNotFound(format!("get_result_ptr: {}", e)))?;

        let get_result_len = instance
            .get_typed_func::<(), i32>(&mut store, "get_result_len")
            .map_err(|e| WasmError::FunctionNotFound(format!("get_result_len: {}", e)))?;

        // Allocate memory for context
        let context_bytes = context.as_bytes();
        let ptr = alloc
            .call(&mut store, context_bytes.len() as i32)
            .map_err(|e| {
                if e.to_string().contains("fuel") {
                    WasmError::OutOfFuel
                } else {
                    WasmError::ExecutionError(e.to_string())
                }
            })?;

        // Copy context to WASM memory
        memory
            .write(&mut store, ptr as usize, context_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Memory write failed: {}", e)))?;

        // Call the function
        let _result_code = target_fn
            .call(&mut store, (ptr, context_bytes.len() as i32))
            .map_err(|e| {
                if e.to_string().contains("fuel") {
                    WasmError::OutOfFuel
                } else {
                    WasmError::ExecutionError(e.to_string())
                }
            })?;

        // Get result
        let result_ptr = get_result_ptr
            .call(&mut store, ())
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?
            as usize;
        let result_len = get_result_len
            .call(&mut store, ())
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?
            as usize;

        // Read result from memory
        let mut result_bytes = vec![0u8; result_len];
        memory
            .read(&store, result_ptr, &mut result_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Memory read failed: {}", e)))?;

        String::from_utf8(result_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Invalid UTF-8 result: {}", e)))
    }

    /// Execute a simple expression-like WASM module
    /// This is a simpler API for basic operations
    pub fn execute_simple(&self, wasm_bytes: &[u8], context: &str) -> Result<String, WasmError> {
        self.execute(wasm_bytes, "analyze", context)
    }

    /// Get remaining fuel after execution
    pub fn remaining_fuel(&self, store: &Store<()>) -> u64 {
        store.get_fuel().unwrap_or(0)
    }
}

/// Pre-compiled WASM modules for common operations
pub struct WasmLibrary {
    modules: HashMap<String, Vec<u8>>,
}

impl WasmLibrary {
    /// Create a new library with built-in modules
    pub fn new() -> Self {
        let mut modules = HashMap::new();

        // Simple line counter module - minimal version that works
        let line_counter_wat = r#"
(module
  (memory (export "memory") 1)

  (global $result_ptr (mut i32) (i32.const 0))
  (global $result_len (mut i32) (i32.const 0))
  (global $heap_ptr (mut i32) (i32.const 1024))

  (func (export "alloc") (param $size i32) (result i32)
    (local $ptr i32)
    (local.set $ptr (global.get $heap_ptr))
    (global.set $heap_ptr (i32.add (global.get $heap_ptr) (local.get $size)))
    (local.get $ptr)
  )

  (func $count_newlines (param $ptr i32) (param $len i32) (result i32)
    (local $i i32)
    (local $count i32)
    (local.set $count (i32.const 1))
    (local.set $i (i32.const 0))
    (block $break
      (loop $continue
        (br_if $break (i32.ge_u (local.get $i) (local.get $len)))
        (if (i32.eq (i32.load8_u (i32.add (local.get $ptr) (local.get $i))) (i32.const 10))
          (then (local.set $count (i32.add (local.get $count) (i32.const 1))))
        )
        (local.set $i (i32.add (local.get $i) (i32.const 1)))
        (br $continue)
      )
    )
    (local.get $count)
  )

  (func $store_int_result (param $num i32)
    (local $temp i32)
    (local $digits i32)
    (local $i i32)
    (local $digit i32)

    (if (i32.eqz (local.get $num))
      (then
        (i32.store8 (i32.const 0) (i32.const 48))
        (global.set $result_ptr (i32.const 0))
        (global.set $result_len (i32.const 1))
        (return)
      )
    )

    (local.set $temp (local.get $num))
    (local.set $digits (i32.const 0))
    (block $count_done
      (loop $count_loop
        (br_if $count_done (i32.eqz (local.get $temp)))
        (local.set $temp (i32.div_u (local.get $temp) (i32.const 10)))
        (local.set $digits (i32.add (local.get $digits) (i32.const 1)))
        (br $count_loop)
      )
    )

    (local.set $temp (local.get $num))
    (local.set $i (i32.sub (local.get $digits) (i32.const 1)))
    (block $write_done
      (loop $write_loop
        (br_if $write_done (i32.lt_s (local.get $i) (i32.const 0)))
        (local.set $digit (i32.rem_u (local.get $temp) (i32.const 10)))
        (i32.store8 (local.get $i) (i32.add (i32.const 48) (local.get $digit)))
        (local.set $temp (i32.div_u (local.get $temp) (i32.const 10)))
        (local.set $i (i32.sub (local.get $i) (i32.const 1)))
        (br $write_loop)
      )
    )

    (global.set $result_ptr (i32.const 0))
    (global.set $result_len (local.get $digits))
  )

  (func $do_count_lines (param $ptr i32) (param $len i32) (result i32)
    (local $count i32)
    (local.set $count (call $count_newlines (local.get $ptr) (local.get $len)))
    (call $store_int_result (local.get $count))
    (local.get $count)
  )

  (func (export "count_lines") (param $ptr i32) (param $len i32) (result i32)
    (call $do_count_lines (local.get $ptr) (local.get $len))
  )

  (func (export "analyze") (param $ptr i32) (param $len i32) (result i32)
    (call $do_count_lines (local.get $ptr) (local.get $len))
  )

  (func (export "get_result_ptr") (result i32)
    (global.get $result_ptr)
  )

  (func (export "get_result_len") (result i32)
    (global.get $result_len)
  )
)
"#;

        // Compile and add line counter with error logging
        match wat::parse_str(line_counter_wat) {
            Ok(wasm) => {
                modules.insert("line_counter".to_string(), wasm);
            }
            Err(e) => {
                eprintln!("Failed to compile line_counter WAT: {}", e);
            }
        }

        Self { modules }
    }

    /// Get a pre-compiled module by name
    pub fn get(&self, name: &str) -> Option<&Vec<u8>> {
        self.modules.get(name)
    }

    /// List available modules
    pub fn list(&self) -> Vec<&str> {
        self.modules.keys().map(|s| s.as_str()).collect()
    }
}

impl Default for WasmLibrary {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wasm_executor_creation() {
        let config = WasmConfig::default();
        let executor = WasmExecutor::new(config);
        assert!(executor.is_ok());
    }

    #[test]
    fn test_compile_simple_wat() {
        let config = WasmConfig::default();
        let executor = WasmExecutor::new(config).unwrap();

        let wat = r#"(module)"#;
        let result = executor.compile_wat(wat);
        assert!(result.is_ok());
    }

    #[test]
    fn test_line_counter_library() {
        let library = WasmLibrary::new();
        assert!(library.get("line_counter").is_some());
    }

    #[test]
    fn test_execute_line_counter() {
        let config = WasmConfig::default();
        let executor = WasmExecutor::new(config).unwrap();
        let library = WasmLibrary::new();

        let module = library.get("line_counter").unwrap();
        let context = "line1\nline2\nline3";

        let result = executor.execute(module, "count_lines", context);
        assert!(result.is_ok(), "Execution failed: {:?}", result);
        assert_eq!(result.unwrap(), "3");
    }
}
