//! WebAssembly execution for dynamic code in RLM
//!
//! This module provides safe, sandboxed execution of WASM modules
//! generated by the LLM for complex analysis tasks.
//!
//! ## Modules
//!
//! - `compiler` - Rust to WASM compilation
//! - `cache` - Module caching for compiled WASM

#[cfg(test)]
mod benchmark_tests;
pub mod cache;
pub mod compiler;
#[cfg(test)]
mod demo_tests;
pub mod library;
#[cfg(test)]
mod security_tests;
pub mod templates;

pub use cache::{CacheConfig, CacheStats, ModuleCache};
pub use compiler::{CompileError, CompilerConfig, RustCompiler};
pub use library::{ToolDescription, WasmToolLibrary};
pub use templates::{PrebuiltHooks, TemplateFramework, TemplateType};

use std::collections::HashMap;
use thiserror::Error;
use wasmtime::*;

/// Errors from WASM execution
#[derive(Error, Debug)]
pub enum WasmError {
    #[error("WASM compilation failed: {0}")]
    CompileError(String),

    #[error("WASM execution failed: {0}")]
    ExecutionError(String),

    #[error("WASM function not found: {0}")]
    FunctionNotFound(String),

    #[error("WASM out of fuel (instruction limit exceeded)")]
    OutOfFuel,

    #[error("WASM memory limit exceeded")]
    MemoryLimit,

    #[error("Invalid WAT syntax: {0}")]
    WatError(String),

    #[error("Type mismatch: expected {expected}, got {got}")]
    TypeMismatch { expected: String, got: String },
}

/// Configuration for WASM execution
#[derive(Debug, Clone)]
pub struct WasmConfig {
    /// Maximum instructions (fuel) before aborting
    pub fuel_limit: u64,
    /// Maximum memory in bytes
    pub memory_limit: usize,
    /// Timeout in milliseconds (not yet implemented)
    pub timeout_ms: u64,
}

impl Default for WasmConfig {
    fn default() -> Self {
        Self {
            fuel_limit: 1_000_000,          // 1M instructions
            memory_limit: 64 * 1024 * 1024, // 64MB
            timeout_ms: 5000,               // 5 seconds
        }
    }
}

/// WASM executor with sandboxing
pub struct WasmExecutor {
    engine: Engine,
    config: WasmConfig,
}

impl WasmExecutor {
    /// Create a new WASM executor
    pub fn new(config: WasmConfig) -> Result<Self, WasmError> {
        let mut engine_config = Config::new();
        engine_config.consume_fuel(true);

        let engine =
            Engine::new(&engine_config).map_err(|e| WasmError::CompileError(e.to_string()))?;

        Ok(Self { engine, config })
    }

    /// Compile WAT (WebAssembly Text) to a WASM module
    pub fn compile_wat(&self, wat: &str) -> Result<Vec<u8>, WasmError> {
        wat::parse_str(wat).map_err(|e| WasmError::WatError(e.to_string()))
    }

    /// Execute a WASM module with the given function and context
    ///
    /// The WASM module should export:
    /// - `alloc(size: i32) -> i32`: allocate memory for input
    /// - `free(ptr: i32, size: i32)`: free allocated memory
    /// - `<function>(ptr: i32, len: i32) -> i32`: the analysis function
    /// - `get_result_ptr() -> i32`: get pointer to result
    /// - `get_result_len() -> i32`: get length of result
    pub fn execute(
        &self,
        wasm_bytes: &[u8],
        function: &str,
        context: &str,
    ) -> Result<String, WasmError> {
        // Create a store with fuel limit
        let mut store = Store::new(&self.engine, ());
        store
            .set_fuel(self.config.fuel_limit)
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?;

        // Compile the module
        let module = Module::new(&self.engine, wasm_bytes)
            .map_err(|e| WasmError::CompileError(e.to_string()))?;

        // Create instance
        let instance = Instance::new(&mut store, &module, &[])
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?;

        // Get memory
        let memory = instance
            .get_memory(&mut store, "memory")
            .ok_or_else(|| WasmError::ExecutionError("No memory export".to_string()))?;

        // Get required functions
        let alloc = instance
            .get_typed_func::<i32, i32>(&mut store, "alloc")
            .map_err(|e| WasmError::FunctionNotFound(format!("alloc: {}", e)))?;

        let target_fn = instance
            .get_typed_func::<(i32, i32), i32>(&mut store, function)
            .map_err(|e| WasmError::FunctionNotFound(format!("{}: {}", function, e)))?;

        let get_result_ptr = instance
            .get_typed_func::<(), i32>(&mut store, "get_result_ptr")
            .map_err(|e| WasmError::FunctionNotFound(format!("get_result_ptr: {}", e)))?;

        let get_result_len = instance
            .get_typed_func::<(), i32>(&mut store, "get_result_len")
            .map_err(|e| WasmError::FunctionNotFound(format!("get_result_len: {}", e)))?;

        // Allocate memory for context
        let context_bytes = context.as_bytes();
        let ptr = alloc
            .call(&mut store, context_bytes.len() as i32)
            .map_err(|e| {
                if e.to_string().contains("fuel") {
                    WasmError::OutOfFuel
                } else {
                    WasmError::ExecutionError(e.to_string())
                }
            })?;

        // Copy context to WASM memory
        memory
            .write(&mut store, ptr as usize, context_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Memory write failed: {}", e)))?;

        // Call the function
        let _result_code = target_fn
            .call(&mut store, (ptr, context_bytes.len() as i32))
            .map_err(|e| {
                if e.to_string().contains("fuel") {
                    WasmError::OutOfFuel
                } else {
                    WasmError::ExecutionError(e.to_string())
                }
            })?;

        // Get result
        let result_ptr = get_result_ptr
            .call(&mut store, ())
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?
            as usize;
        let result_len = get_result_len
            .call(&mut store, ())
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?
            as usize;

        // Read result from memory
        let mut result_bytes = vec![0u8; result_len];
        memory
            .read(&store, result_ptr, &mut result_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Memory read failed: {}", e)))?;

        String::from_utf8(result_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Invalid UTF-8 result: {}", e)))
    }

    /// Execute a simple expression-like WASM module
    /// This is a simpler API for basic operations
    pub fn execute_simple(&self, wasm_bytes: &[u8], context: &str) -> Result<String, WasmError> {
        self.execute(wasm_bytes, "analyze", context)
    }

    /// Get remaining fuel after execution
    pub fn remaining_fuel(&self, store: &Store<()>) -> u64 {
        store.get_fuel().unwrap_or(0)
    }

    /// Create a reduce instance for streaming data processing
    ///
    /// The WASM module should export:
    /// - `alloc(size: i32) -> i32`: allocate memory for input
    /// - `reduce_init()`: initialize the state
    /// - `reduce_chunk(ptr: i32, len: i32)`: process a chunk of data
    /// - `reduce_finalize()`: finalize and produce the result
    /// - `get_result_ptr() -> i32`: get pointer to result
    /// - `get_result_len() -> i32`: get length of result
    pub fn create_reduce_instance(
        &self,
        wasm_bytes: &[u8],
    ) -> Result<ReduceInstance, WasmError> {
        // Create a store with fuel limit
        let mut store = Store::new(&self.engine, ());
        store
            .set_fuel(self.config.fuel_limit)
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?;

        // Compile the module
        let module = Module::new(&self.engine, wasm_bytes)
            .map_err(|e| WasmError::CompileError(e.to_string()))?;

        // Create instance
        let instance = Instance::new(&mut store, &module, &[])
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?;

        // Verify required exports exist
        // Note: reduce functions return i32 (0 for success)
        instance
            .get_typed_func::<i32, i32>(&mut store, "alloc")
            .map_err(|e| WasmError::FunctionNotFound(format!("alloc: {}", e)))?;
        instance
            .get_typed_func::<(), i32>(&mut store, "reduce_init")
            .map_err(|e| WasmError::FunctionNotFound(format!("reduce_init: {}", e)))?;
        instance
            .get_typed_func::<(i32, i32), i32>(&mut store, "reduce_chunk")
            .map_err(|e| WasmError::FunctionNotFound(format!("reduce_chunk: {}", e)))?;
        instance
            .get_typed_func::<(), i32>(&mut store, "reduce_finalize")
            .map_err(|e| WasmError::FunctionNotFound(format!("reduce_finalize: {}", e)))?;

        Ok(ReduceInstance {
            store,
            instance,
            initialized: false,
        })
    }
}

/// A WASM instance for streaming reduce operations
///
/// Holds state across multiple chunk processing calls.
pub struct ReduceInstance {
    store: Store<()>,
    instance: Instance,
    initialized: bool,
}

impl ReduceInstance {
    /// Initialize the reduce state
    ///
    /// Must be called once before processing any chunks.
    pub fn init(&mut self) -> Result<(), WasmError> {
        if self.initialized {
            return Err(WasmError::ExecutionError(
                "Reduce instance already initialized".to_string(),
            ));
        }

        let reduce_init = self
            .instance
            .get_typed_func::<(), i32>(&mut self.store, "reduce_init")
            .map_err(|e| WasmError::FunctionNotFound(format!("reduce_init: {}", e)))?;

        let _result = reduce_init.call(&mut self.store, ()).map_err(|e| {
            if e.to_string().contains("fuel") {
                WasmError::OutOfFuel
            } else {
                WasmError::ExecutionError(e.to_string())
            }
        })?;

        self.initialized = true;
        Ok(())
    }

    /// Process a chunk of data
    ///
    /// The chunk will be split into lines and each line processed by the reducer.
    /// Can be called multiple times to process large datasets in pieces.
    pub fn process_chunk(&mut self, chunk: &str) -> Result<(), WasmError> {
        if !self.initialized {
            return Err(WasmError::ExecutionError(
                "Reduce instance not initialized - call init() first".to_string(),
            ));
        }

        // Get memory and functions
        let memory = self
            .instance
            .get_memory(&mut self.store, "memory")
            .ok_or_else(|| WasmError::ExecutionError("No memory export".to_string()))?;

        let alloc = self
            .instance
            .get_typed_func::<i32, i32>(&mut self.store, "alloc")
            .map_err(|e| WasmError::FunctionNotFound(format!("alloc: {}", e)))?;

        let reduce_chunk = self
            .instance
            .get_typed_func::<(i32, i32), i32>(&mut self.store, "reduce_chunk")
            .map_err(|e| WasmError::FunctionNotFound(format!("reduce_chunk: {}", e)))?;

        // Allocate memory for chunk
        let chunk_bytes = chunk.as_bytes();
        let ptr = alloc
            .call(&mut self.store, chunk_bytes.len() as i32)
            .map_err(|e| {
                if e.to_string().contains("fuel") {
                    WasmError::OutOfFuel
                } else {
                    WasmError::ExecutionError(e.to_string())
                }
            })?;

        // Copy chunk to WASM memory
        memory
            .write(&mut self.store, ptr as usize, chunk_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Memory write failed: {}", e)))?;

        // Process the chunk
        let _result = reduce_chunk
            .call(&mut self.store, (ptr, chunk_bytes.len() as i32))
            .map_err(|e| {
                if e.to_string().contains("fuel") {
                    WasmError::OutOfFuel
                } else {
                    WasmError::ExecutionError(e.to_string())
                }
            })?;

        Ok(())
    }

    /// Finalize the reduce operation and get the result
    ///
    /// After calling this, the instance should not be used for further processing.
    pub fn finalize(&mut self) -> Result<String, WasmError> {
        if !self.initialized {
            return Err(WasmError::ExecutionError(
                "Reduce instance not initialized - call init() first".to_string(),
            ));
        }

        // Get required functions
        let reduce_finalize = self
            .instance
            .get_typed_func::<(), i32>(&mut self.store, "reduce_finalize")
            .map_err(|e| WasmError::FunctionNotFound(format!("reduce_finalize: {}", e)))?;

        let get_result_ptr = self
            .instance
            .get_typed_func::<(), i32>(&mut self.store, "get_result_ptr")
            .map_err(|e| WasmError::FunctionNotFound(format!("get_result_ptr: {}", e)))?;

        let get_result_len = self
            .instance
            .get_typed_func::<(), i32>(&mut self.store, "get_result_len")
            .map_err(|e| WasmError::FunctionNotFound(format!("get_result_len: {}", e)))?;

        // Finalize the reduce
        let _result = reduce_finalize.call(&mut self.store, ()).map_err(|e| {
            if e.to_string().contains("fuel") {
                WasmError::OutOfFuel
            } else {
                WasmError::ExecutionError(e.to_string())
            }
        })?;

        // Get memory to read result
        let memory = self
            .instance
            .get_memory(&mut self.store, "memory")
            .ok_or_else(|| WasmError::ExecutionError("No memory export".to_string()))?;

        // Get result
        let result_ptr = get_result_ptr
            .call(&mut self.store, ())
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?
            as usize;
        let result_len = get_result_len
            .call(&mut self.store, ())
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?
            as usize;

        // Read result from memory
        let mut result_bytes = vec![0u8; result_len];
        memory
            .read(&self.store, result_ptr, &mut result_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Memory read failed: {}", e)))?;

        String::from_utf8(result_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Invalid UTF-8 result: {}", e)))
    }

    /// Get remaining fuel in this instance
    pub fn remaining_fuel(&self) -> u64 {
        self.store.get_fuel().unwrap_or(0)
    }
}

/// A WASM instance for stateless map operations
///
/// Maps each line to key-value pairs (WASM is stateless, aggregation in native Rust)
pub struct MapInstance {
    store: Store<()>,
    instance: Instance,
    fuel_limit: u64,
}

impl MapInstance {
    /// Map a single line to key-value pairs
    ///
    /// Returns pairs as Vec<(key, value)> for aggregation in native Rust.
    pub fn map_line(&mut self, line: &str) -> Result<Vec<(String, String)>, WasmError> {
        // Refresh fuel for this line call - each line gets its own fuel budget
        self.store
            .set_fuel(self.fuel_limit)
            .map_err(|e| WasmError::ExecutionError(format!("Failed to set fuel: {}", e)))?;

        // Get memory and functions
        let memory = self
            .instance
            .get_memory(&mut self.store, "memory")
            .ok_or_else(|| WasmError::ExecutionError("No memory export".to_string()))?;

        let alloc = self
            .instance
            .get_typed_func::<i32, i32>(&mut self.store, "alloc")
            .map_err(|e| WasmError::FunctionNotFound(format!("alloc: {}", e)))?;

        let map_one = self
            .instance
            .get_typed_func::<(i32, i32), i32>(&mut self.store, "map_one")
            .map_err(|e| WasmError::FunctionNotFound(format!("map_one: {}", e)))?;

        let get_result_ptr = self
            .instance
            .get_typed_func::<(), i32>(&mut self.store, "get_result_ptr")
            .map_err(|e| WasmError::FunctionNotFound(format!("get_result_ptr: {}", e)))?;

        let get_result_len = self
            .instance
            .get_typed_func::<(), i32>(&mut self.store, "get_result_len")
            .map_err(|e| WasmError::FunctionNotFound(format!("get_result_len: {}", e)))?;

        // Allocate memory for line
        let line_bytes = line.as_bytes();
        let ptr = alloc
            .call(&mut self.store, line_bytes.len() as i32)
            .map_err(|e| {
                if e.to_string().contains("fuel") {
                    WasmError::OutOfFuel
                } else {
                    WasmError::ExecutionError(e.to_string())
                }
            })?;

        // Copy line to WASM memory
        memory
            .write(&mut self.store, ptr as usize, line_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Memory write failed: {}", e)))?;

        // Map the line
        let _result = map_one
            .call(&mut self.store, (ptr, line_bytes.len() as i32))
            .map_err(|e| {
                if e.to_string().contains("fuel") {
                    WasmError::OutOfFuel
                } else {
                    WasmError::ExecutionError(e.to_string())
                }
            })?;

        // Get result
        let result_ptr = get_result_ptr
            .call(&mut self.store, ())
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?
            as usize;
        let result_len = get_result_len
            .call(&mut self.store, ())
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?
            as usize;

        // Read result from memory
        if result_len == 0 {
            return Ok(Vec::new());
        }

        let mut result_bytes = vec![0u8; result_len];
        memory
            .read(&self.store, result_ptr, &mut result_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Memory read failed: {}", e)))?;

        let result_str = String::from_utf8(result_bytes)
            .map_err(|e| WasmError::ExecutionError(format!("Invalid UTF-8 result: {}", e)))?;

        // Parse "key\tvalue\nkey2\tvalue2..." format
        let mut pairs = Vec::new();
        for line in result_str.lines() {
            if let Some(tab_pos) = line.find('\t') {
                let key = line[..tab_pos].to_string();
                let value = line[tab_pos + 1..].to_string();
                pairs.push((key, value));
            }
        }

        Ok(pairs)
    }

    /// Get remaining fuel in this instance
    pub fn remaining_fuel(&self) -> u64 {
        self.store.get_fuel().unwrap_or(0)
    }
}

impl WasmExecutor {
    /// Create a map instance for stateless line-by-line processing
    ///
    /// The WASM module should export:
    /// - `alloc(size: i32) -> i32`: allocate memory for input
    /// - `map_one(ptr: i32, len: i32) -> i32`: map a line to key-value pairs
    /// - `get_result_ptr() -> i32`: get pointer to result
    /// - `get_result_len() -> i32`: get length of result
    pub fn create_map_instance(
        &self,
        wasm_bytes: &[u8],
    ) -> Result<MapInstance, WasmError> {
        // Create a store with fuel limit
        let mut store = Store::new(&self.engine, ());
        store
            .set_fuel(self.config.fuel_limit)
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?;

        // Compile the module
        let module = Module::new(&self.engine, wasm_bytes)
            .map_err(|e| WasmError::CompileError(e.to_string()))?;

        // Create instance
        let instance = Instance::new(&mut store, &module, &[])
            .map_err(|e| WasmError::ExecutionError(e.to_string()))?;

        // Verify required exports exist
        instance
            .get_typed_func::<i32, i32>(&mut store, "alloc")
            .map_err(|e| WasmError::FunctionNotFound(format!("alloc: {}", e)))?;
        instance
            .get_typed_func::<(i32, i32), i32>(&mut store, "map_one")
            .map_err(|e| WasmError::FunctionNotFound(format!("map_one: {}", e)))?;

        Ok(MapInstance { store, instance, fuel_limit: self.config.fuel_limit })
    }
}

/// Pre-compiled WASM modules for common operations
pub struct WasmLibrary {
    modules: HashMap<String, Vec<u8>>,
}

impl WasmLibrary {
    /// Create a new library with built-in modules
    pub fn new() -> Self {
        let mut modules = HashMap::new();

        // Simple line counter module - minimal version that works
        let line_counter_wat = r#"
(module
  (memory (export "memory") 1)

  (global $result_ptr (mut i32) (i32.const 0))
  (global $result_len (mut i32) (i32.const 0))
  (global $heap_ptr (mut i32) (i32.const 1024))

  (func (export "alloc") (param $size i32) (result i32)
    (local $ptr i32)
    (local.set $ptr (global.get $heap_ptr))
    (global.set $heap_ptr (i32.add (global.get $heap_ptr) (local.get $size)))
    (local.get $ptr)
  )

  (func $count_newlines (param $ptr i32) (param $len i32) (result i32)
    (local $i i32)
    (local $count i32)
    (local.set $count (i32.const 1))
    (local.set $i (i32.const 0))
    (block $break
      (loop $continue
        (br_if $break (i32.ge_u (local.get $i) (local.get $len)))
        (if (i32.eq (i32.load8_u (i32.add (local.get $ptr) (local.get $i))) (i32.const 10))
          (then (local.set $count (i32.add (local.get $count) (i32.const 1))))
        )
        (local.set $i (i32.add (local.get $i) (i32.const 1)))
        (br $continue)
      )
    )
    (local.get $count)
  )

  (func $store_int_result (param $num i32)
    (local $temp i32)
    (local $digits i32)
    (local $i i32)
    (local $digit i32)

    (if (i32.eqz (local.get $num))
      (then
        (i32.store8 (i32.const 0) (i32.const 48))
        (global.set $result_ptr (i32.const 0))
        (global.set $result_len (i32.const 1))
        (return)
      )
    )

    (local.set $temp (local.get $num))
    (local.set $digits (i32.const 0))
    (block $count_done
      (loop $count_loop
        (br_if $count_done (i32.eqz (local.get $temp)))
        (local.set $temp (i32.div_u (local.get $temp) (i32.const 10)))
        (local.set $digits (i32.add (local.get $digits) (i32.const 1)))
        (br $count_loop)
      )
    )

    (local.set $temp (local.get $num))
    (local.set $i (i32.sub (local.get $digits) (i32.const 1)))
    (block $write_done
      (loop $write_loop
        (br_if $write_done (i32.lt_s (local.get $i) (i32.const 0)))
        (local.set $digit (i32.rem_u (local.get $temp) (i32.const 10)))
        (i32.store8 (local.get $i) (i32.add (i32.const 48) (local.get $digit)))
        (local.set $temp (i32.div_u (local.get $temp) (i32.const 10)))
        (local.set $i (i32.sub (local.get $i) (i32.const 1)))
        (br $write_loop)
      )
    )

    (global.set $result_ptr (i32.const 0))
    (global.set $result_len (local.get $digits))
  )

  (func $do_count_lines (param $ptr i32) (param $len i32) (result i32)
    (local $count i32)
    (local.set $count (call $count_newlines (local.get $ptr) (local.get $len)))
    (call $store_int_result (local.get $count))
    (local.get $count)
  )

  (func (export "count_lines") (param $ptr i32) (param $len i32) (result i32)
    (call $do_count_lines (local.get $ptr) (local.get $len))
  )

  (func (export "analyze") (param $ptr i32) (param $len i32) (result i32)
    (call $do_count_lines (local.get $ptr) (local.get $len))
  )

  (func (export "get_result_ptr") (result i32)
    (global.get $result_ptr)
  )

  (func (export "get_result_len") (result i32)
    (global.get $result_len)
  )
)
"#;

        // Compile and add line counter with error logging
        match wat::parse_str(line_counter_wat) {
            Ok(wasm) => {
                modules.insert("line_counter".to_string(), wasm);
            }
            Err(e) => {
                eprintln!("Failed to compile line_counter WAT: {}", e);
            }
        }

        Self { modules }
    }

    /// Get a pre-compiled module by name
    pub fn get(&self, name: &str) -> Option<&Vec<u8>> {
        self.modules.get(name)
    }

    /// List available modules
    pub fn list(&self) -> Vec<&str> {
        self.modules.keys().map(|s| s.as_str()).collect()
    }
}

impl Default for WasmLibrary {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::wasm::compiler::{CompilerConfig, RustCompiler};

    #[test]
    fn test_wasm_executor_creation() {
        let config = WasmConfig::default();
        let executor = WasmExecutor::new(config);
        assert!(executor.is_ok());
    }

    #[test]
    fn test_compile_simple_wat() {
        let config = WasmConfig::default();
        let executor = WasmExecutor::new(config).unwrap();

        let wat = r#"(module)"#;
        let result = executor.compile_wat(wat);
        assert!(result.is_ok());
    }

    #[test]
    fn test_line_counter_library() {
        let library = WasmLibrary::new();
        assert!(library.get("line_counter").is_some());
    }

    #[test]
    fn test_execute_line_counter() {
        let config = WasmConfig::default();
        let executor = WasmExecutor::new(config).unwrap();
        let library = WasmLibrary::new();

        let module = library.get("line_counter").unwrap();
        let context = "line1\nline2\nline3";

        let result = executor.execute(module, "count_lines", context);
        assert!(result.is_ok(), "Execution failed: {:?}", result);
        assert_eq!(result.unwrap(), "3");
    }

    #[test]
    fn test_reduce_execution() {
        // This test requires the compiler to produce reduce WASM
        // We'll use a pre-compiled approach or skip if compiler unavailable
        let config = CompilerConfig::default();
        let compiler = match RustCompiler::new(config) {
            Ok(c) => c,
            Err(_) => {
                println!("Skipping reduce test: rustc not available");
                return;
            }
        };

        let reduce_code = r#"
struct State {
    line_count: usize,
    error_count: usize,
}

fn init_state() -> State {
    State {
        line_count: 0,
        error_count: 0,
    }
}

fn process_line(state: &mut State, line: &str) {
    state.line_count += 1;
    if has(line, "ERROR") {
        state.error_count += 1;
    }
}

fn finalize(state: &State) -> String {
    format!("Lines: {}, Errors: {}", state.line_count, state.error_count)
}
        "#;

        let wasm_bytes = match compiler.compile_reduce(reduce_code) {
            Ok(bytes) => bytes,
            Err(e) => {
                panic!("Failed to compile reduce code: {}", e);
            }
        };

        // Create executor and reduce instance
        let exec_config = WasmConfig::default();
        let executor = WasmExecutor::new(exec_config).unwrap();
        let mut reduce_instance = executor
            .create_reduce_instance(&wasm_bytes)
            .expect("Failed to create reduce instance");

        // Initialize
        reduce_instance.init().expect("Failed to init reduce");

        // Process some lines
        let test_data = "INFO: Starting up\nERROR: Something went wrong\nINFO: Continuing\nERROR: Another error\n";
        reduce_instance
            .process_chunk(test_data)
            .expect("Failed to process chunk");

        // Finalize and get result
        let result = reduce_instance
            .finalize()
            .expect("Failed to finalize reduce");

        assert!(
            result.contains("Lines: 4"),
            "Expected 4 lines, got: {}",
            result
        );
        assert!(
            result.contains("Errors: 2"),
            "Expected 2 errors, got: {}",
            result
        );
        println!("Reduce result: {}", result);
    }
}
